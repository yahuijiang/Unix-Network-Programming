1. TCP

  RTT: 客户和服务器之间的往返时间
  每个TCP是有序号的，接收端接到分解后，会根据他们的序号进行重新的排序，然后交给应用程序
  流量控制： 告诉对方一次能接受多少字节的数据
  MSS： 在SYN中需要告诉对方本链接中的每个tcp分节可以接受的最大数据量。（MTU是ip层的限制，叫做最大传输单元，也就是每个ip数据包最大的字节数）

  1. 服务器端准备接受链接：通过socket,bind,listen 这三个函数来完成， 客户端通过connect来主动打开链接
    三次握手:
    1. 客户端通过connect主动打开链接，发送SYN,告诉服务器自己的初始序列号。
    2. 服务器发送SYN 的ack， 同时发送自己的SYN，告诉客户端自己使用的初始序列号
    3. 客户端对服务区的SYN 进行确认

    四次挥手：
    1. 发起段调用close，执行主动关闭，这引起TCP 发送一个FIN，表示本端不会再发送数据。
    2. 接收端对FIN 进行确认，执行被动关闭，表示本端不会再接收到数据。对FIN确认的同时也想接收端程序发送一个EOF
    3. 接收端程序收到EOF 后调用close 关闭套接字，这导致TCP发送一个FIN
    4. 发起段对FIN进行确认。
  
    对一个请求的处理:
      1. 三次握手建立链接
      2. 客户端发起一个请求（假设发送一个包）
      3. 服务器对包进行确认并相应请求， 在这期间如果对请求的处理时间较短，那么可以随着相应数据一块发送对包的ack。否则应该先发送ack， 再发送reply
      4. 四次挥手

    TIME_WAIT 状态
    四次握手中，当发起段执行到第三步的时候，发起端会进入到TIME_WAIT状态，这个状态的时间一般是包存活周期的2倍（2MST）
    保持这个状态的原因有两个:
       1. 可靠的实现全双工链接终止：例如如果另一端发起的FIN丢失了，则需要等待其再次发送的FIN
       2. 使老的FIN包在网络中消息： 例如:如果另一端发送的FIN并不是丢失而是延迟了，并且另一端又发送了一个FIN, 如果不保持这个状态直接关闭了本连接。随后新的连接又建立起来了，
                                      并且使用的是原来连接的参数，那么新的连接就有可能收到一个老的FIN，导致错误的关闭连接。

  2. TCP输出
    
    +----------+                       +---------------------------+
    |应用进程  |                       | 引用进程缓冲区（任意大小）|
    +----------+                       +---------------------------+
        |                                           |                     用户进程
   -----|-------------------------------------------|---------------------------
        |                                           |                       内核
    +--------+                         +---------------------------+
    |  TCP   |                         |套接字发送缓冲区           |
    +--------+                         +---------------------------+
        |                                           |
        |                                           |    MSS 大小的TCP分节
    +--------+                                      |
    |   IP   |                                      \/
    +--------+
        |                                           |
        |                                           |     MTU大小的ipv4/ipv6分组
    +--------+                                      \/
    |输出队列|
    ----------
    |数据链路|
    +--------+

        应用程序调用write将应用缓冲区的数据写到套接字缓冲区，套接字缓冲区如果没有足够的大小，write将block。
        只有收到对方的ack，套接字缓冲区才能将发送缓冲区的数据丢弃。否则过段时间会重发。







